function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _typeof$1(obj) {
  if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
    _typeof$1 = function _typeof$1(obj) {
      return _typeof(obj);
    };
  } else {
    _typeof$1 = function _typeof$1(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
    };
  }

  return _typeof$1(obj);
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

function findParent(elem) {
  if (elem.parentNode) {
    // Accounting for https://bugs.webkit.org/show_bug.cgi?id=161454
    var dataset = JSON.parse(JSON.stringify(elem.parentNode.dataset));

    if (dataset.module) {
      return elem.parentNode;
    }

    return findParent(elem.parentNode);
  }

  return elem;
}
/* global window */


function attrObj(key, el) {
  var values = {};
  Object.keys(el.dataset).forEach(function (data) {
    if (data.match(new RegExp("^".concat(key))) && data !== key) {
      var optionName = data.replace(key, '');
      var isGlobal = false;

      if (optionName.match(/^Global/)) {
        optionName = optionName.replace('Global', '');
        isGlobal = true;
      }

      optionName = "".concat(optionName[0].toLowerCase()).concat(optionName.slice(1));

      if (isGlobal) {
        values[optionName] = window[el.dataset[data]];
      } else {
        values[optionName] = el.dataset[data];
      }

      if (typeof values[optionName] === 'undefined' || values[optionName] === '') {
        values[optionName] = true;
      }
    }
  });
  return values;
}

function _typeof$1$1(obj) {
  if (typeof Symbol === "function" && _typeof$1(Symbol.iterator) === "symbol") {
    _typeof$1$1 = function _typeof$1$1(obj) {
      return _typeof$1(obj);
    };
  } else {
    _typeof$1$1 = function _typeof$1$1(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof$1(obj);
    };
  }

  return _typeof$1$1(obj);
}
/* eslint-disable no-restricted-syntax, guard-for-in, prefer-rest-params, no-use-before-define */


var aug = function aug() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  args.unshift(false);
  return merge.apply(null, args);
};

aug.defaults = function () {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  args.unshift(true);
  return merge.apply(null, args);
}; // first arg is 'true' if using defaults-only version
// first arg is 'false' if just doing deep merge:


function merge() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  var useDefaults = args[0];
  var destObject = {}; // for each object in the rest of the argument list:

  args.slice(1, args.length).forEach(function (prop) {
    // for each property in the current object:
    for (var propName in prop) {
      // default-only mode skips the property if it's not present in the first object
      if (useDefaults && args[1][propName] === undefined) {
        return;
      } // get the value we are going to assign to the dest object:


      var propValue = prop[propName]; // if that value is an array just assign it to the dest object:

      if (Array.isArray(propValue)) {
        destObject[propName] = propValue;
        continue;
      } // if the source and destination values are both objects then recursively merge them:


      if (_typeof$1$1(propValue) === 'object' && _typeof$1$1(destObject[propName]) === 'object') {
        // get the right merging function for the recursive merge:
        var merger = useDefaults ? aug.defaults : aug;
        destObject[propName] = merger(destObject[propName], propValue);
        continue;
      } // otherwise just assign the value to the destination object:


      destObject[propName] = propValue;
    }
  });
  return destObject;
}

function isWindow(obj) {
  return obj != null && obj === obj.window;
}

function find(selector) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (selector instanceof HTMLElement || selector instanceof Node || isWindow(selector)) {
    return [selector];
  } else if (selector instanceof NodeList) {
    return [].slice.call(selector);
  } else if (typeof selector === 'string') {
    var startElement = context ? find(context)[0] : document;
    return [].slice.call(startElement.querySelectorAll(selector));
  }

  return [];
}

function on(selector, event, cb) {
  var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (Array.isArray(selector)) {
    selector.forEach(function (item) {
      return on(item, event, cb, capture);
    });
    return;
  }

  var data = {
    cb: cb,
    capture: capture
  };

  if (!window._domassistevents) {
    window._domassistevents = {};
  }

  window._domassistevents["_".concat(event)] = data;
  var el = find(selector);

  if (el.length) {
    el.forEach(function (item) {
      item.addEventListener(event, cb, capture);
    });
  }
}

function findOne(selector, el) {
  var found = find(selector, el);

  if (found.length) {
    return found[0];
  }

  return null;
}

var NativeCustomEvent = window.CustomEvent; //
// Check for the usage of native support for CustomEvents which is lacking
// completely on IE.
//

function canIuseNativeCustom() {
  try {
    var p = new NativeCustomEvent('t', {
      detail: {
        a: 'b'
      }
    });
    return p.type === 't' && p.detail.a === 'b';
  } catch (e) {
    return false;
  }
} // Lousy polyfill for the Custom Event constructor for IE.


var IECustomEvent = function CustomEvent(type, params) {
  var e = document.createEvent('CustomEvent');

  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, undefined);
  }

  return e;
};

var DomassistCustomEvent = canIuseNativeCustom() ? NativeCustomEvent : IECustomEvent;
var SCROLLABLE_CONTAINER;

function getScrollableContainer() {
  if (SCROLLABLE_CONTAINER) {
    return SCROLLABLE_CONTAINER;
  }

  var documentElement = window.document.documentElement;
  var scrollableContainer;
  documentElement.scrollTop = 1;

  if (documentElement.scrollTop === 1) {
    documentElement.scrollTop = 0;
    scrollableContainer = documentElement;
  } else {
    scrollableContainer = document.body;
  }

  SCROLLABLE_CONTAINER = scrollableContainer;
  return scrollableContainer;
}

SCROLLABLE_CONTAINER = getScrollableContainer();
var ACTION_SELECTOR = '[data-action]';
var DOMAssist = {
  find: find,
  findOne: findOne,
  on: on
};

var Domodule =
/*#__PURE__*/
function () {
  function Domodule(el) {
    _classCallCheck$1(this, Domodule);

    this.log('begin setup');
    this.el = el;
    this.els = {};
    this.options = aug({}, this.defaults, attrObj('module', this.el));
    this.moduleName = this.el.dataset.module;
    this.setUps = {
      actions: [],
      named: [],
      options: []
    };
    this.boundActionRouter = this.actionRouter.bind(this);
    this.preInit();
    this.storeRef();
    this.setupActions();
    this.setupNamed();
    this.verifyRequired();
    this.postInit();
    this.log('initalized');

    if (Domodule.debug) {
      this.el.module = this;
    }

    return this;
  }

  _createClass$1(Domodule, [{
    key: "preInit",
    value: function preInit() {}
  }, {
    key: "postInit",
    value: function postInit() {}
  }, {
    key: "verifyRequired",
    value: function verifyRequired() {
      var _this = this;

      if (this.required === {}) {
        return this;
      }

      if (typeof this.required.options !== 'undefined') {
        this.setUps.options = Object.keys(this.options);
      }

      Object.keys(this.required).forEach(function (required) {
        _this.required[required].forEach(function (value) {
          if (_this.setUps[required].indexOf(value) < 0) {
            throw new Error("".concat(value, " is required as ").concat(required, " for ").concat(_this.moduleName, ", but is missing!"));
          }
        });
      });
      return this;
    }
  }, {
    key: "setupActions",
    value: function setupActions() {
      var _this2 = this;

      this.setupAction(this.el);
      this.find(ACTION_SELECTOR).forEach(function (action) {
        var parent = findParent(action);

        if (parent === _this2.el) {
          _this2.setupAction(action);
        }
      });
    }
  }, {
    key: "setupAction",
    value: function setupAction(actionEl) {
      if (actionEl.dataset.domoduleActionProcessed === 'true') {
        return;
      }

      var _Domodule$parseAction = Domodule.parseAction(actionEl),
          actionName = _Domodule$parseAction.name,
          actionType = _Domodule$parseAction.type;

      if (!actionName) {
        return;
      } else if (typeof this[actionName] !== 'function') {
        this.log("".concat(actionName, " was registered, but there is no function set up"));
        return;
      }

      this.log("".concat(actionName, " bound"));
      this.storeSetUp(actionName, 'actions');
      DOMAssist.on(actionEl, actionType, this.boundActionRouter);
      actionEl.dataset.domoduleActionProcessed = 'true';
    }
  }, {
    key: "actionRouter",
    value: function actionRouter(event) {
      var actionEl = event.currentTarget;

      var _Domodule$parseAction2 = Domodule.parseAction(actionEl),
          actionName = _Domodule$parseAction2.name;

      var actionData = attrObj('action', actionEl);
      this[actionName].call(this, actionEl, event, actionData);
    }
  }, {
    key: "setupNamed",
    value: function setupNamed() {
      var _this3 = this;

      this.find('[data-name]').forEach(function (named) {
        var parent = findParent(named);

        if (parent !== _this3.el) {
          return;
        }

        if (!named.dataset.domoduleNameProcessed) {
          _this3.els[named.dataset.name] = named;

          _this3.storeSetUp(named.dataset.name, 'named');

          named.dataset.domoduleNameProcessed = 'true';
          named.dataset.domoduleOwner = _this3.id;
        }
      });
    }
  }, {
    key: "storeRef",
    value: function storeRef() {
      if (typeof window.domorefs === 'undefined') {
        window.domorefs = {};
      }

      if (typeof window.domorefs[this.el.dataset.moduleUid] !== 'undefined') {
        return false;
      }

      this.id = this.uuid;
      this.el.dataset.moduleUid = this.id;
      window.domorefs[this.el.dataset.moduleUid] = this;
    }
  }, {
    key: "find",
    value: function find(selector) {
      return DOMAssist.find(selector, this.el);
    }
  }, {
    key: "findOne",
    value: function findOne(selector) {
      return DOMAssist.findOne(selector, this.el);
    }
  }, {
    key: "findByName",
    value: function findByName(name) {
      return this.els[name];
    }
  }, {
    key: "getOption",
    value: function getOption(option) {
      return this.options[option];
    }
  }, {
    key: "storeSetUp",
    value: function storeSetUp(name, dict) {
      if (this.setUps[dict].indexOf(name) < 0) {
        this.setUps[dict].push(name);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this4 = this;

      DOMAssist.find(ACTION_SELECTOR, this.el.parentNode).forEach(function (el) {
        if (el.dataset.domoduleActionProcessed === 'true') {
          var _Domodule$parseAction3 = Domodule.parseAction(el),
              actionType = _Domodule$parseAction3.type;

          el.removeEventListener(actionType, _this4.boundActionRouter);
          el.dataset.domoduleActionProcessed = 'false';
        }
      });
    } // static methods can't access `this` so they go last

  }, {
    key: "log",
    //used inside instance
    value: function log(msg) {
      Domodule.log("".concat(this.constructor.name, ": ").concat(msg));
    }
  }, {
    key: "required",
    get: function get() {
      return {};
    }
  }, {
    key: "defaults",
    get: function get() {
      return {};
    }
  }, {
    key: "uuid",
    get: function get() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }
  }], [{
    key: "parseAction",
    value: function parseAction(el) {
      var _el$dataset = el.dataset,
          name = _el$dataset.action,
          _el$dataset$actionTyp = _el$dataset.actionType,
          type = _el$dataset$actionTyp === void 0 ? 'click' : _el$dataset$actionTyp;
      return {
        name: name,
        type: type
      };
    }
  }, {
    key: "getInstance",
    value: function getInstance(element) {
      if (element instanceof Node) {
        return window.domorefs[element.dataset.moduleUid];
      }

      throw new Error('getInstance expects a dom node');
    }
  }, {
    key: "register",
    value: function register(name, cls) {
      if (typeof name === 'function') {
        cls = name;
        name = cls.prototype.constructor.name;
      }

      if (!window.domodules) {
        window.domodules = {};
      }

      Domodule.log("Registering ".concat(name));
      window.domodules[name] = cls;
    }
  }, {
    key: "discover",
    value: function discover() {
      var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'body';
      Domodule.log('Discovering modules...');

      if (!window.domodules) {
        Domodule.log('No modules found');
        return;
      }

      var els;

      if (el instanceof Node) {
        els = [el];
      } else if (Array.isArray(el)) {
        els = el;
      } else {
        els = DOMAssist.find(el);
      }

      var instances = [];
      els.forEach(function (matched) {
        var foundModules = DOMAssist.find('[data-module]', matched);
        foundModules.forEach(function (moduleEl) {
          var moduleName = moduleEl.dataset.module;

          if (moduleName && typeof window.domodules[moduleName] === 'function') {
            if (_typeof$1(window.domorefs) === 'object' && typeof window.domorefs[moduleEl.dataset.moduleUid] !== 'undefined') {
              return;
            }

            Domodule.log("".concat(moduleName, " found"));
            instances.push(new window.domodules[moduleName](moduleEl));
          }
        });
      });
      return instances;
    }
  }, {
    key: "log",
    value: function log(msg) {
      if (Domodule.debug) {
        console.log("[DOMODULE] ".concat(msg)); //eslint-disable-line no-console
      }
    }
  }]);

  return Domodule;
}();

Domodule.debug = _typeof$1(window.localStorage) === 'object' && window.localStorage.getItem('DomoduleDebug');
Domodule.autoDiscover = true;
window.addEventListener('DOMContentLoaded', function () {
  if (Domodule.autoDiscover) {
    Domodule.discover();
  }
});

function isWindow$1(obj) {
  return obj != null && obj === obj.window;
}

function find$1(selector) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (selector instanceof HTMLElement || selector instanceof Node || isWindow$1(selector)) {
    return [selector];
  } else if (selector instanceof NodeList) {
    return [].slice.call(selector);
  } else if (typeof selector === 'string') {
    var startElement = context ? find$1(context)[0] : document;
    return [].slice.call(startElement.querySelectorAll(selector));
  }

  return [];
}

function on$1(selector, event, cb) {
  var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (Array.isArray(selector)) {
    selector.forEach(function (item) {
      return on$1(item, event, cb, capture);
    });
    return;
  }

  var data = {
    cb: cb,
    capture: capture
  };

  if (!window._domassistevents) {
    window._domassistevents = {};
  }

  window._domassistevents["_".concat(event)] = data;
  var el = find$1(selector);

  if (el.length) {
    el.forEach(function (item) {
      item.addEventListener(event, cb, capture);
    });
  }
}

function findOne$1(selector, el) {
  var found = find$1(selector, el);

  if (found.length) {
    return found[0];
  }

  return null;
}

var NativeCustomEvent$1 = window.CustomEvent; //
// Check for the usage of native support for CustomEvents which is lacking
// completely on IE.
//

function canIuseNativeCustom$1() {
  try {
    var p = new NativeCustomEvent$1('t', {
      detail: {
        a: 'b'
      }
    });
    return p.type === 't' && p.detail.a === 'b';
  } catch (e) {
    return false;
  }
} // Lousy polyfill for the Custom Event constructor for IE.


var IECustomEvent$1 = function CustomEvent(type, params) {
  var e = document.createEvent('CustomEvent');

  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, undefined);
  }

  return e;
};

var DomassistCustomEvent$1 = canIuseNativeCustom$1() ? NativeCustomEvent$1 : IECustomEvent$1;

var SCROLLABLE_CONTAINER$1;

function getScrollableContainer$1() {
  if (SCROLLABLE_CONTAINER$1) {
    return SCROLLABLE_CONTAINER$1;
  }

  var documentElement = window.document.documentElement;
  var scrollableContainer;
  documentElement.scrollTop = 1;

  if (documentElement.scrollTop === 1) {
    documentElement.scrollTop = 0;
    scrollableContainer = documentElement;
  } else {
    scrollableContainer = document.body;
  }

  SCROLLABLE_CONTAINER$1 = scrollableContainer;
  return scrollableContainer;
}

SCROLLABLE_CONTAINER$1 = getScrollableContainer$1();

var BASE_URLS = {
  twitter: 'https://twitter.com/intent/tweet',
  facebook: 'https://www.facebook.com/sharer/sharer.php',
  gplus: 'https://plus.google.com/share',
  linkedin: 'https://www.linkedin.com/shareArticle'
};

var SocialShareButton =
/*#__PURE__*/
function (_Domodule) {
  _inherits(SocialShareButton, _Domodule);

  function SocialShareButton() {
    _classCallCheck(this, SocialShareButton);

    return _possibleConstructorReturn(this, _getPrototypeOf(SocialShareButton).apply(this, arguments));
  }

  _createClass(SocialShareButton, [{
    key: "postInit",
    value: function postInit() {
      var _this = this;

      var setupMethod = "".concat(this.options.net, "Setup");
      var shareMethod = "".concat(this.options.net, "Share");

      if (!this[shareMethod] && !this[setupMethod]) {
        throw new Error("Sharing method for ".concat(this.options.net, " is not implemented"));
      }

      if (this[setupMethod]) {
        this[setupMethod]();
      }

      if (this[shareMethod]) {
        on$1(this.el, 'click', function (e) {
          e.preventDefault();

          _this[shareMethod]();
        });
      }
    }
  }, {
    key: "getShareUrl",
    value: function getShareUrl() {
      var url = window.location.href;

      if (this.options.baseUrl) {
        if (this.options.relative) {
          url = "".concat(window.location.origin).concat(window.location.pathname).concat(this.options.baseUrl);
        } else {
          url = this.options.baseUrl;
        }
      }

      return url;
    }
  }, {
    key: "gplusShare",
    value: function gplusShare() {
      SocialShareButton.openWindow(this.el.href, '600', '500', 'gplusWindow');
    }
  }, {
    key: "twitterShare",
    value: function twitterShare() {
      SocialShareButton.openWindow(this.el.href, '260', '500', 'twitterWindow');
    }
  }, {
    key: "linkedinShare",
    value: function linkedinShare() {
      SocialShareButton.openWindow(this.el.href, '520', '570', 'linkedinWindow');
    }
  }, {
    key: "facebookShare",
    value: function facebookShare() {
      if (typeof window.FB !== 'undefined' && typeof window.FB.ui !== 'undefined') {
        var object = {
          method: 'share',
          href: this.getShareUrl()
        };

        if (this.options.tag) {
          object.hashtag = "#".concat(this.options.tag);
        }

        if (this.options.text) {
          object.quote = this.options.text;
        }

        FB.ui(object);
      } else {
        SocialShareButton.openWindow(this.el.href, '440', '600', 'facebookWindow');
      }
    }
  }, {
    key: "facebookSetup",
    value: function facebookSetup() {
      var params = ["u=".concat(this.getShareUrl())];

      if (this.options.tag) {
        params.push("hashtag=".concat(encodeURIComponent("#".concat(this.options.tag))));
      }

      if (this.options.text) {
        params.push("quote=".concat(encodeURIComponent(this.options.text)));
      }

      this.el.href = "".concat(BASE_URLS.facebook, "?").concat(params.join('&'));
    }
  }, {
    key: "emailSetup",
    value: function emailSetup() {
      var title = encodeURIComponent(this.options.subject || document.title);
      var body = this.options.body || 'Check this out #url';
      body = body.replace(/#url/gi, this.getShareUrl());
      body = encodeURIComponent(body);
      this.el.href = "mailto:?subject=".concat(title, "&body=").concat(body);
    }
  }, {
    key: "gplusSetup",
    value: function gplusSetup() {
      this.el.href = "".concat(BASE_URLS.gplus, "?url=").concat(this.getShareUrl());
    }
  }, {
    key: "linkedinSetup",
    value: function linkedinSetup() {
      var params = ["url=".concat(encodeURIComponent(this.getShareUrl()))];
      var shareText = this.options.text;
      var shareTitle = this.options.title;

      if (shareText) {
        params.push("summary=".concat(encodeURIComponent(shareText)));
      }

      if (shareTitle) {
        params.push("title=".concat(encodeURIComponent(shareTitle)));
      }

      this.el.href = "".concat(BASE_URLS.linkedin, "?mini=true&").concat(params.join('&'));
    }
  }, {
    key: "twitterSetup",
    value: function twitterSetup() {
      var shareText = this.options.text || SocialShareButton.getTwiMeta('text');
      var shareTag = this.options.tags || SocialShareButton.getTwiMeta('hashtag');
      var shareVia = this.options.via || SocialShareButton.getTwiMeta('author');
      var params = [];
      params.push("url=".concat(encodeURIComponent(this.getShareUrl())));

      if (shareText) {
        params.push("text=".concat(encodeURIComponent(shareText)));
      }

      if (shareTag && shareTag !== 'none') {
        params.push("hashtags=".concat(encodeURIComponent(shareTag)));
      }

      if (shareVia && shareVia !== 'none') {
        params.push("via=".concat(encodeURIComponent(shareVia)));
      }

      this.el.href = "".concat(BASE_URLS.twitter, "?").concat(params.join('&'));
    }
  }, {
    key: "required",
    get: function get() {
      return {
        options: ['net']
      };
    }
  }, {
    key: "defaults",
    get: function get() {
      return {
        relative: false,
        baseUrl: false
      };
    }
  }], [{
    key: "getTwiMeta",
    value: function getTwiMeta(tag) {
      var meta = findOne$1("meta[property=\"twi:".concat(tag, "\"]"));
      return meta ? meta.getAttribute('content') : null;
    }
  }, {
    key: "openWindow",
    value: function openWindow(url, height, width, key) {
      window.open(url, key, "menubar=no,toolbar=no,left=200,top=200,resizable=yes,scrollbars=no,height=".concat(height, ",width=").concat(width));
    }
  }]);

  return SocialShareButton;
}(Domodule);
Domodule.register('SocialShareButton', SocialShareButton);

export default SocialShareButton;
//# sourceMappingURL=social-share-button.esm.js.map
